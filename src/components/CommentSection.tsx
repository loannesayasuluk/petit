import {
  Box,
  Text,
  Textarea,
  Button,
  Group,
  Stack,
  Divider,
  Alert,
  Card,
  ActionIcon,
  Menu,
  Loader,
  Center,
  Collapse
} from '@mantine/core';
import { IconMessage, IconDots, IconEdit, IconTrash, IconCornerDownRight, IconHeart, IconHeartFilled } from '@tabler/icons-react';
import { useState, useEffect } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { EmptyState } from './EmptyState';
import { 
  createComment, 
  subscribeToComments, 
  updateComment, 
  deleteComment,
  toggleCommentLike 
} from '../services/commentService';
import type { Comment } from '../types';

interface CommentSectionProps {
  postId: string;
}

function formatTimeAgo(date: Date): string {
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);
  
  if (diffInSeconds < 60) return 'Î∞©Í∏à Ï†Ñ';
  if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}Î∂Ñ Ï†Ñ`;
  if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}ÏãúÍ∞Ñ Ï†Ñ`;
  return `${Math.floor(diffInSeconds / 86400)}Ïùº Ï†Ñ`;
}

interface CommentItemProps {
  comment: Comment;
  currentUserId?: string;
  userProfile: any;
  postId: string;
  onEdit: (commentId: string, content: string) => void;
  onDelete: (commentId: string) => void;
  onReply: (parentId: string, content: string) => void;
  onLike: (commentId: string) => void;
  depth?: number;
}

function CommentItem({ 
  comment, 
  currentUserId, 
  userProfile,
  postId,
  onEdit, 
  onDelete, 
  onReply,
  onLike,
  depth = 0 
}: CommentItemProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [isReplying, setIsReplying] = useState(false);
  const [editContent, setEditContent] = useState(comment.content);
  const [replyContent, setReplyContent] = useState('');
  const [loading, setLoading] = useState(false);
  const [replyLoading, setReplyLoading] = useState(false);
  const [likeLoading, setLikeLoading] = useState(false);
  
  const isOwner = currentUserId === comment.author.uid;
  const isLiked = currentUserId ? comment.likes?.includes(currentUserId) : false;
  const maxDepth = 3; // ÏµúÎåÄ 3Îã®Í≥ÑÍπåÏßÄÎßå Ï§ëÏ≤© ÌóàÏö©

  const handleEditSubmit = async () => {
    if (!editContent.trim()) return;
    
    setLoading(true);
    try {
      await onEdit(comment.id, editContent.trim());
      setIsEditing(false);
    } catch (error) {
      console.error('ÎåìÍ∏Ä ÏàòÏ†ï Ïò§Î•ò:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleEditCancel = () => {
    setEditContent(comment.content);
    setIsEditing(false);
  };

  const handleReplySubmit = async () => {
    if (!replyContent.trim()) return;
    
    setReplyLoading(true);
    try {
      await onReply(comment.id, replyContent.trim());
      setReplyContent('');
      setIsReplying(false);
    } catch (error) {
      console.error('ÎåÄÎåìÍ∏Ä ÏûëÏÑ± Ïò§Î•ò:', error);
    } finally {
      setReplyLoading(false);
    }
  };

  const handleReplyCancel = () => {
    setReplyContent('');
    setIsReplying(false);
  };

  const handleLikeClick = async () => {
    if (likeLoading || !currentUserId) return;
    
    setLikeLoading(true);
    try {
      await onLike(comment.id);
    } finally {
      setTimeout(() => setLikeLoading(false), 300);
    }
  };

  return (
    <Box>
      <Card 
        withBorder 
        radius="md" 
        p="md"
        style={{ 
          marginLeft: depth > 0 ? `${depth * 20}px` : 0,
          borderLeft: depth > 0 ? '3px solid var(--mantine-color-blue-2)' : undefined
        }}
      >
        <Group justify="space-between" mb="xs">
          <Group gap="xs">
            <Text size="sm" fw={600}>
              {comment.author.avatar || 'üë§'} {comment.author.nickname}
            </Text>
            <Text size="xs" c="dimmed">
              {formatTimeAgo(comment.createdAt)}
            </Text>
          </Group>
          
          {isOwner && (
            <Menu shadow="md" width={120}>
              <Menu.Target>
                <ActionIcon variant="subtle" size="sm" color="gray">
                  <IconDots size="1rem" />
                </ActionIcon>
              </Menu.Target>
              <Menu.Dropdown>
                <Menu.Item
                  leftSection={<IconEdit size="0.9rem" />}
                  onClick={() => setIsEditing(true)}
                >
                  ÏàòÏ†ï
                </Menu.Item>
                <Menu.Item
                  leftSection={<IconTrash size="0.9rem" />}
                  color="red"
                  onClick={() => onDelete(comment.id)}
                >
                  ÏÇ≠Ï†ú
                </Menu.Item>
              </Menu.Dropdown>
            </Menu>
          )}
        </Group>

        {isEditing ? (
          <Stack gap="sm">
            <Textarea
              value={editContent}
              onChange={(e) => setEditContent(e.currentTarget.value)}
              placeholder="ÎåìÍ∏ÄÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."
              autosize
              minRows={2}
              maxRows={6}
            />
            <Group gap="sm" justify="flex-end">
              <Button
                variant="subtle"
                size="sm"
                onClick={handleEditCancel}
                disabled={loading}
              >
                Ï∑®ÏÜå
              </Button>
              <Button
                size="sm"
                onClick={handleEditSubmit}
                loading={loading}
                disabled={!editContent.trim()}
              >
                ÏàòÏ†ï
              </Button>
            </Group>
          </Stack>
        ) : (
          <>
            <Text size="sm" style={{ whiteSpace: 'pre-wrap' }} mb="sm">
              {comment.content}
            </Text>
            
            {/* ÎåìÍ∏Ä Ïï°ÏÖò Î≤ÑÌäºÎì§ */}
            <Group gap="md" justify="space-between">
              <Group gap="sm">
                {/* Ï¢ãÏïÑÏöî Î≤ÑÌäº */}
                {currentUserId && (
                  <Group gap="xs">
                    <ActionIcon
                      variant="subtle"
                      color={isLiked ? 'red' : 'gray'}
                      size="sm"
                      onClick={handleLikeClick}
                      loading={likeLoading}
                      style={{
                        transform: isLiked ? 'scale(1.1)' : 'scale(1)',
                        transition: 'all 0.2s ease',
                      }}
                    >
                      {isLiked ? (
                        <IconHeartFilled 
                          size={14} 
                          style={{ 
                            animation: isLiked ? 'heartBeat 0.6s ease-in-out' : undefined 
                          }} 
                        />
                      ) : (
                        <IconHeart size={14} />
                      )}
                    </ActionIcon>
                    <Text 
                      size="xs" 
                      fw={isLiked ? 600 : 400}
                      c={isLiked ? 'red' : 'dimmed'}
                    >
                      {comment.likes?.length || 0}
                    </Text>
                  </Group>
                )}
              </Group>

              {/* ÎãµÍ∏Ä Î≤ÑÌäº */}
              {currentUserId && depth < maxDepth && (
                <Button
                  variant="subtle"
                  size="xs"
                  leftSection={<IconCornerDownRight size="0.8rem" />}
                  onClick={() => setIsReplying(true)}
                  color="blue"
                >
                  ÎãµÍ∏Ä
                </Button>
              )}
            </Group>
          </>
        )}

        {/* ÎãµÍ∏Ä ÏûëÏÑ± Ìèº */}
        <Collapse in={isReplying}>
          <Box mt="md" pt="md" style={{ borderTop: '1px solid var(--mantine-color-gray-3)' }}>
            <Group gap="xs" mb="sm">
              <Text size="sm" fw={600}>
                {userProfile?.avatar || 'üë§'} {userProfile?.nickname || 'ÏÇ¨Ïö©Ïûê'}
              </Text>
              <Text size="xs" c="dimmed">ÎãµÍ∏Ä ÏûëÏÑ± Ï§ë...</Text>
            </Group>
            
            <Stack gap="sm">
              <Textarea
                placeholder={`${comment.author.nickname}ÎãòÏóêÍ≤å ÎãµÍ∏ÄÏùÑ ÎÇ®Í≤®Î≥¥ÏÑ∏Ïöî...`}
                value={replyContent}
                onChange={(e) => setReplyContent(e.currentTarget.value)}
                autosize
                minRows={2}
                maxRows={4}
              />
              <Group justify="space-between">
                <Text size="xs" c="dimmed">
                  {replyContent.length}/500Ïûê
                </Text>
                <Group gap="sm">
                  <Button
                    variant="subtle"
                    size="sm"
                    onClick={handleReplyCancel}
                    disabled={replyLoading}
                  >
                    Ï∑®ÏÜå
                  </Button>
                  <Button
                    size="sm"
                    onClick={handleReplySubmit}
                    loading={replyLoading}
                    disabled={!replyContent.trim() || replyContent.length > 500}
                  >
                    ÎãµÍ∏Ä ÏûëÏÑ±
                  </Button>
                </Group>
              </Group>
            </Stack>
          </Box>
        </Collapse>
      </Card>

      {/* ÎåÄÎåìÍ∏Ä Î†åÎçîÎßÅ */}
      {comment.replies && comment.replies.length > 0 && (
        <Box mt="sm">
          {comment.replies.map((reply) => (
            <Box key={reply.id} mt="sm">
              <CommentItem
                comment={reply}
                currentUserId={currentUserId}
                userProfile={userProfile}
                postId={postId}
                onEdit={onEdit}
                onDelete={onDelete}
                onReply={onReply}
                onLike={onLike}
                depth={depth + 1}
              />
            </Box>
          ))}
        </Box>
      )}
    </Box>
  );
}

export function CommentSection({ postId }: CommentSectionProps) {
  const { currentUser, userProfile } = useAuth();
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [commentsLoading, setCommentsLoading] = useState(true);

  // Ï¥ù ÎåìÍ∏Ä Ïàò Í≥ÑÏÇ∞ (ÎåÄÎåìÍ∏Ä Ìè¨Ìï®)
  const getTotalCommentCount = (comments: Comment[]): number => {
    let count = 0;
    comments.forEach(comment => {
      count += 1; // Ìï¥Îãπ ÎåìÍ∏Ä
      if (comment.replies) {
        count += getTotalCommentCount(comment.replies); // ÎåÄÎåìÍ∏ÄÎì§
      }
    });
    return count;
  };

  // Ïã§ÏãúÍ∞Ñ ÎåìÍ∏Ä Íµ¨ÎèÖ
  useEffect(() => {
    const unsubscribe = subscribeToComments(postId, (updatedComments) => {
      setComments(updatedComments);
      setCommentsLoading(false);
    });

    return unsubscribe;
  }, [postId]);

  const handleSubmitComment = async () => {
    if (!currentUser || !userProfile) {
      setError('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
      return;
    }

    if (!newComment.trim()) {
      setError('ÎåìÍ∏Ä ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
      return;
    }

    setLoading(true);
    setError('');

    try {
      await createComment({
        postId,
        content: newComment.trim(),
        author: {
          uid: currentUser.uid,
          nickname: userProfile.nickname,
          avatar: userProfile.avatar,
        }
      });
      
      setNewComment('');
    } catch (error) {
      console.error('ÎåìÍ∏Ä ÏûëÏÑ± Ïò§Î•ò:', error);
      setError('ÎåìÍ∏Ä ÏûëÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    } finally {
      setLoading(false);
    }
  };

  const handleReplyComment = async (parentId: string, content: string) => {
    if (!currentUser || !userProfile) return;

    try {
      await createComment({
        postId,
        parentId,
        content,
        author: {
          uid: currentUser.uid,
          nickname: userProfile.nickname,
          avatar: userProfile.avatar,
        }
      });
    } catch (error) {
      console.error('ÎåÄÎåìÍ∏Ä ÏûëÏÑ± Ïò§Î•ò:', error);
      throw error;
    }
  };

  const handleEditComment = async (commentId: string, content: string) => {
    try {
      await updateComment(commentId, content);
    } catch (error) {
      console.error('ÎåìÍ∏Ä ÏàòÏ†ï Ïò§Î•ò:', error);
      throw error;
    }
  };

  const handleDeleteComment = async (commentId: string) => {
    if (!confirm('Ï†ïÎßê ÎåìÍ∏ÄÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) return;
    
    try {
      await deleteComment(commentId);
    } catch (error) {
      console.error('ÎåìÍ∏Ä ÏÇ≠Ï†ú Ïò§Î•ò:', error);
      alert('ÎåìÍ∏Ä ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    }
  };

  const handleCommentLike = async (commentId: string) => {
    if (!currentUser) {
      alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
      return;
    }

    try {
      await toggleCommentLike(commentId, currentUser.uid);
    } catch (error) {
      console.error('ÎåìÍ∏Ä Ï¢ãÏïÑÏöî Ïò§Î•ò:', error);
      alert('Ï¢ãÏïÑÏöî Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    }
  };

  const totalCommentsCount = getTotalCommentCount(comments);

  return (
    <Box>
      <Divider 
        my="xl" 
        labelPosition="center" 
        label={
          <Group gap="xs">
            <IconMessage size="1rem" />
            <Text fw={600}>ÎåìÍ∏Ä ({totalCommentsCount})</Text>
          </Group>
        } 
      />

      {/* ÎåìÍ∏Ä ÏûëÏÑ± */}
      {currentUser ? (
        <Card withBorder radius="md" p="md" mb="md">
          <Stack gap="sm">
            <Group gap="xs" mb="xs">
              <Text size="sm" fw={600}>
                {userProfile?.avatar || 'üë§'} {userProfile?.nickname || 'ÏÇ¨Ïö©Ïûê'}
              </Text>
            </Group>
            
            <Textarea
              placeholder="Îî∞ÎúªÌïú ÎåìÍ∏ÄÏùÑ ÎÇ®Í≤®Ï£ºÏÑ∏Ïöî..."
              value={newComment}
              onChange={(e) => setNewComment(e.currentTarget.value)}
              autosize
              minRows={2}
              maxRows={6}
              error={error}
            />
            
            <Group justify="space-between">
              <Text size="xs" c="dimmed">
                {newComment.length}/500Ïûê
              </Text>
              <Button
                onClick={handleSubmitComment}
                loading={loading}
                disabled={!newComment.trim() || newComment.length > 500}
                size="sm"
              >
                ÎåìÍ∏Ä ÏûëÏÑ±
              </Button>
            </Group>
          </Stack>
        </Card>
      ) : (
        <Alert mb="md" radius="md">
          ÎåìÍ∏ÄÏùÑ ÏûëÏÑ±ÌïòÎ†§Î©¥ Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.
        </Alert>
      )}

      {/* ÎåìÍ∏Ä Î™©Î°ù */}
      {commentsLoading ? (
        <Center py="xl">
          <Stack align="center" gap="md">
            <Loader size="md" />
            <Text size="sm" c="dimmed">ÎåìÍ∏ÄÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...</Text>
          </Stack>
        </Center>
      ) : comments.length === 0 ? (
        <EmptyState
          illustration="comments"
          title="ÏïÑÏßÅ ÎåìÍ∏ÄÏù¥ ÏóÜÏñ¥Ïöî!"
          description="Ïù¥ Í∏ÄÏóê ÎåÄÌïú Ï≤´ Î≤àÏß∏ ÎåìÍ∏ÄÏùÑ ÎÇ®Í≤®Ï£ºÏÑ∏Ïöî. Îî∞ÎúªÌïú ÏÜåÌÜµÏùò ÏãúÏûëÏù¥ ÎêòÏñ¥Ï£ºÏÑ∏Ïöî! üí¨"
          actionText={currentUser ? "üí¨ Ï≤´ ÎåìÍ∏Ä Ïì∞Í∏∞" : "üöÄ Î°úÍ∑∏Ïù∏ÌïòÍ≥† ÎåìÍ∏ÄÏì∞Í∏∞"}
          onAction={() => {
            if (currentUser) {
              // ÎåìÍ∏Ä ÏûÖÎ†•Ï∞ΩÏúºÎ°ú Ìè¨Ïª§Ïä§
              const textarea = document.querySelector('textarea[placeholder*="ÎåìÍ∏Ä"]') as HTMLTextAreaElement;
              textarea?.focus();
            } else {
              // TODO: Î°úÍ∑∏Ïù∏ Î™®Îã¨ Ïó¥Í∏∞
              console.log('Î°úÍ∑∏Ïù∏ ÌïÑÏöî');
            }
          }}
          size="sm"
        />
      ) : (
        <Stack gap="md">
          {comments.map((comment) => (
            <CommentItem
              key={comment.id}
              comment={comment}
              currentUserId={currentUser?.uid}
              userProfile={userProfile}
              postId={postId}
              onEdit={handleEditComment}
              onDelete={handleDeleteComment}
              onReply={handleReplyComment}
              onLike={handleCommentLike}
              depth={0}
            />
          ))}
        </Stack>
      )}
    </Box>
  );
} 